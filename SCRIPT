-- SERVICES

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- LOCALS

local Client = Players.LocalPlayer

-- LIBARIES

local SuccessBCL,ByteCodeUtility = pcall(game.HttpGet, game, "https://raw.githubusercontent.com/R00T66/INF/main/Dependants/BCL")

if not SuccessBCL then
   
   Client:Kick("\n\nBYTECODE LIB ERROR")
   
   return
else
   ByteCodeUtility = loadstring(ByteCodeUtility)()
end

local SuccessNUI,NotificationUI = pcall(game.HttpGet, game, "https://raw.githubusercontent.com/R00T66/INF/main/Dependants/NUI")

if not SuccessNUI then
   
   Client:Kick("\n\nNOTIFICATION UI ERROR")
   
   return
else
   NotificationUI = loadstring(NotificationUI)()
end

local SuccessUTI, DeepwokenUtility = pcall(game.HttpGet, game, "https://raw.githubusercontent.com/R00T66/INF/main/Dependants/UTI")

if not SuccessUTI then
   
   Client:Kick("\n\nUTILITY LIB ERROR")
   
   return
else
   DeepwokenUtility = loadstring(DeepwokenUtility)()
end

-- MAIN

local Enchants = { }

local RefreshLog = function(data)
   for i, enchants in pairs(Enchants) do
   
      if Players:FindFirstChild(enchants.Player) then
         if enchants.Data == data then
            print(enchants.Tool.Parent, Players[enchants.Player].Character)
            if enchants.Tool.Parent == Players[enchants.Player].Character then
               table.remove(Enchants, i)
            end
         end
      else
         table.remove(Enchants, i)
      end
      
   end
end

local Logged = function(data)
   
   local bool = false;
   
   for i, logged in pairs(Enchants) do
      if logged.Data == data then 
         bool = true
      end
   end
   
   return bool
end

local WeaponCheck = function(lv, j, x, v)
   
   table.insert(Enchants, {
      Data = lv,
      Tool = x,
      Player = v.Name
   });
   
   local Info = { }
   
   Info["Enchant"] = j.Enchant;
   Info["Weapon"] = DeepwokenUtility.AdjustName(x.Name);
   Info["Player"] = v.Name;
   
   if j.SoulBound ~= nil then
      Info["SoulBound"] = "YES"
   else
      Info["SoulBound"] = "NO"
   end
   
   NotificationUI.WeaponNotification(
    Info["Player"], 
    Info["Enchant"],
    Info["Weapon"],
    Info["SoulBound"]
   )
   --[[HistoryUI.LogWeapon(
    
   )]]
end

local AccessoryCheck = function(j, x, v)
   
   table.insert(Enchants, {
      Data = j,
      Tool = x,
      Player = v.Name
   });
   
   local Info = { }
   
   Info["Enchant"] = j;
   Info["Accessory"] = DeepwokenUtility.AdjustName(x.Name);
   Info["Player"] = v.Name;
   
   NotificationUI.AccessoryNotification(
    Info["Player"], 
    Info["Enchant"],
    Info["Accessory"]
   )
   --[[HistoryUI.LogAccessory(
    
   )]]
end

local Check = function(x, v)
   if x:FindFirstChild("WeaponData") then
      
      local MainValue = x:WaitForChild("WeaponData").Value
      local MainJSON = x:WaitForChild("WeaponData").Value
      
      MainJSON = DeepwokenUtility.GetData(MainJSON);
      MainJSON = DeepwokenUtility.AdjustData(MainJSON);
      MainJSON = DeepwokenUtility.Decode(MainJSON);
      
      if MainJSON.Enchant ~= nil and _G.Settings["WEAPON"] and not Logged(MainValue) then
         WeaponCheck(MainValue, MainJSON, x, v)
      else
         return
      end
   elseif x:FindFirstChild("Enchant") then
      
      local MainValue = x:WaitForChild("Enchant").Value
      
      if MainValue ~= "" and _G.Settings["ACCESSORY"] and not Logged(MainValue) then
         AccessoryCheck(MainValue, x, v)
      else
         return
      end
      
   end
end

local Main = function()
   local Success, Err = pcall(function()
       while wait(0.5) do
          local Success, Err = pcall(function()
          
            RefreshLog()
            
            for i, v in pairs(Players:GetPlayers()) do
               if v:FindFirstChild("Backpack") then               
                  for z, x in pairs(v.Backpack:GetChildren()) do
                     if x:IsA("Tool") then
                        Check(x, v)
                     end
                  end
               end
            en
          end)
          
          if not Success then
             --
          end
       end
   end)
end

Main()
--[[
local Cor = coroutine.create(Main)
local Res = coroutine.resume(Cor)]]
